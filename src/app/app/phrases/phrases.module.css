.container {
    display: grid;
    gap: var(--space-6);
    align-items: flex-start;
    position: relative;
    min-height: calc(100vh - 64px);
}

.containerPanelOpen {
    grid-template-columns: 2fr 1fr;
}

.containerPanelClosed {
    grid-template-columns: 1fr;
}

.leftArea {
    flex: 1;
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-4);
    position: sticky;
    top: 0;
    z-index: 40;
    background: var(--color-bg);
    padding: var(--space-4) 0;
    /* Add border to separate when scrolling, optionally */
    border-bottom: 1px solid transparent;
    transition: border-color 0.2s;
}

/* Optional: Add state for stickiness if needed via JS, but simple sticky is fine */

.headerLeft {
    display: flex;
    align-items: center;
    gap: var(--space-4);
    flex: 1;
    /* Allow it to take space for dropzone alignment */
    justify-content: space-between;
    /* Push categories and dropzone */
    flex-wrap: wrap;
    /* Handle mobile */
}

.title {
    font-size: 2rem;
    color: var(--color-fg);
    margin-bottom: var(--space-2);
    /* Maybe hide title on scroll? Or keep it. */
    width: 100%;
    /* Force title to own row? */
}

/* Adjust layout so Title is above, Tabs + DropZone are in a row below, or all in one row. 
   The current page.tsx structure:
   headerLeft > div(Title, Tabs), DropZone
   
   If we want Title to scroll away but Tabs to stick, we need structure change.
   BUT user said "Phrases" header with DropZone and Genre (Tabs).
   So assume whole block sticks.  
*/
.headerLeft>div:first-child {
    display: flex;
    flex-direction: column;
    /* gap: var(--space-2); */
}

.grid {
    display: grid;
    gap: var(--space-4);
    padding-top: var(--space-2);
}

/* Default columns (3 when closed, 2 when open) */
.gridClosed {
    grid-template-columns: repeat(3, minmax(0, 1fr));
}

.gridOpen {
    grid-template-columns: repeat(2, minmax(0, 1fr));
}

.emptyState {
    color: var(--color-fg-muted);
    font-style: italic;
    grid-column: 1 / -1;
    margin-top: var(--space-8);
}

.rightPanel {
    position: sticky;
    top: 0;
    height: calc(100vh - 64px);
    border-left: 1px solid var(--color-border);
    margin-left: -1px;
    padding-left: var(--space-6);
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

/* Mobile Responsive */
/* Mobile Responsive */
@media (max-width: 768px) {

    .containerPanelOpen,
    .containerPanelClosed {
        grid-template-columns: 1fr;
    }

    .gridClosed,
    .gridOpen {
        grid-template-columns: 100%;
        /* Explicitly 100% instead of 1fr to avoid potential overflow issues */
        width: 100%;
        max-width: 100%;
        box-sizing: border-box;
    }

    .rightPanel {
        position: fixed;
        top: 0;
        right: 0;
        width: 85%;
        max-width: 400px;
        height: 100vh;
        z-index: 100;
        background: var(--color-surface);
        box-shadow: var(--shadow-drawer);
        margin-left: 0;
        border-left: none;
        padding: var(--space-4);
        padding-top: var(--space-6);
        transform: translateX(100%);
        transition: transform 0.3s ease;
    }

    /* When panel is visible, logic handled by parent container or inline style? 
       Actually, `isPanelOpen` renders the component. 
       If it is rendered, we want it to slide in.
       We might need an animation class or rely on mounting animation.
       Since it's conditional rendering in React:
       {isPanelOpen && <div className={rightPanel}>...</div>}
       
       We need to ensure it slides in. 
       Better to keep it mounted and toggle class? 
       OR just rely on simple "appear" for now.
       Let's use `transform: translateX(0)` if we want animation, 
       but currently it is unmounted when closed.
       
       If unmounted -> mouted: it will just appear.
       Let's remove transform: translateX(100%) so it is visible when mounted.
    */
    .rightPanel {
        transform: none;
        /* Visible when mounted */
    }
}

.overlay {
    display: none;
}

@media (max-width: 768px) {
    .overlay {
        display: block;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(2px);
        z-index: 90;
        cursor: pointer;
        opacity: 0;
        animation: fadeIn 0.3s forwards;
    }
}

@keyframes fadeIn {
    to {
        opacity: 1;
    }
}