
import { NativeLanguage } from "./translations";

// v1
import en_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_en.json";
import ja_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_ja.json";
import ko_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_ko.json";
import zh_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_zh.json";
import fr_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_fr.json";
import es_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_es.json";
import de_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_de.json";
import ru_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_ru.json";
import vi_v1 from "../../langpack/phase2_L1_langpack/phase2_L1_vi.json";

// v2
import en_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_en.json";
import ja_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_ja.json";
import ko_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_ko.json";
import zh_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_zh.json";
import fr_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_fr.json";
import es_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_es.json";
import de_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_de.json";
import ru_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_ru.json";
import vi_v2 from "../../langpack/phase2_L1_v2_langpack/phase2_L1_v2_vi.json";

// v3
import en_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_en.json";
import ja_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_ja.json";
import ko_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_ko.json";
import zh_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_zh.json";
import fr_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_fr.json";
import es_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_es.json";
import de_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_de.json";
import ru_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_ru.json";
import vi_v3 from "../../langpack/phase2_L1_v3_langpack/phase2_L1_v3_vi.json";

// v4
import en_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_en.json";
import ja_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_ja.json";
import ko_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_ko.json";
import zh_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_zh.json";
import fr_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_fr.json";
import es_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_es.json";
import de_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_de.json";
import ru_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_ru.json";
import vi_v4 from "../../langpack/phase2_L1_v4_langpack/phase2_L1_v4_vi.json";

// v5
import en_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_en.json";
import ja_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_ja.json";
import ko_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_ko.json";
import zh_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_zh.json";
import fr_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_fr.json";
import es_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_es.json";
import de_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_de.json";
import ru_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_ru.json";
import vi_v5 from "../../langpack/phase2_L1_v5_langpack/phase2_L1_v5_vi.json";

// v6
import en_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_en.json";
import ja_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_ja.json";
import ko_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_ko.json";
import zh_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_zh.json";
import fr_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_fr.json";
import es_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_es.json";
import de_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_de.json";
import ru_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_ru.json";
import vi_v6 from "../../langpack/phase2_L1_v6_langpack/phase2_L1_v6_vi.json";

// v7
import en_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_en.json";
import ja_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_ja.json";
import ko_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_ko.json";
import zh_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_zh.json";
import fr_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_fr.json";
import es_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_es.json";
import de_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_de.json";
import ru_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_ru.json";
import vi_v7 from "../../langpack/phase2_L1_v7_langpack/phase2_L1_v7_vi.json";

// v8
import en_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_en.json";
import ja_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_ja.json";
import ko_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_ko.json";
import zh_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_zh.json";
import fr_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_fr.json";
import es_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_es.json";
import de_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_de.json";
import ru_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_ru.json";
import vi_v8 from "../../langpack/phase2_L1_v8_langpack/phase2_L1_v8_vi.json";

// v9
import en_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_en.json";
import ja_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_ja.json";
import ko_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_ko.json";
import zh_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_zh.json";
import fr_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_fr.json";
import es_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_es.json";
import de_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_de.json";
import ru_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_ru.json";
import vi_v9 from "../../langpack/phase2_L1_v9_langpack/phase2_L1_v9_vi.json";

// Merge all versions (v10, v11, v12 excluded - missing files)
const en = [...en_v1, ...en_v2, ...en_v3, ...en_v4, ...en_v5, ...en_v6, ...en_v7, ...en_v8, ...en_v9];
const ja = [...ja_v1, ...ja_v2, ...ja_v3, ...ja_v4, ...ja_v5, ...ja_v6, ...ja_v7, ...ja_v8, ...ja_v9];
const ko = [...ko_v1, ...ko_v2, ...ko_v3, ...ko_v4, ...ko_v5, ...ko_v6, ...ko_v7, ...ko_v8, ...ko_v9];
const zh = [...zh_v1, ...zh_v2, ...zh_v3, ...zh_v4, ...zh_v5, ...zh_v6, ...zh_v7, ...zh_v8, ...zh_v9];
const fr = [...fr_v1, ...fr_v2, ...fr_v3, ...fr_v4, ...fr_v5, ...fr_v6, ...fr_v7, ...fr_v8, ...fr_v9];
const es = [...es_v1, ...es_v2, ...es_v3, ...es_v4, ...es_v5, ...es_v6, ...es_v7, ...es_v8, ...es_v9];
const de = [...de_v1, ...de_v2, ...de_v3, ...de_v4, ...de_v5, ...de_v6, ...de_v7, ...de_v8, ...de_v9];
const ru = [...ru_v1, ...ru_v2, ...ru_v3, ...ru_v4, ...ru_v5, ...ru_v6, ...ru_v7, ...ru_v8, ...ru_v9];
const vi = [...vi_v1, ...vi_v2, ...vi_v3, ...vi_v4, ...vi_v5, ...vi_v6, ...vi_v7, ...vi_v8, ...vi_v9];

export interface LangPackItemItem {
    lang: string;
    targetText: string;
    tokens: string[] | string[][];
    tokensSlash: string;
}

export interface LangPackItem {
    level: string;
    studyType: string;
    deckId: string;
    categoryId: string;
    frameId: string;
    tags: string[];
    gloss_en: string;
    item: LangPackItemItem;
}

export type Phrase = {
    id: string; // frameId
    categoryId: string;
    translation: string; // gloss_en
    translations: {
        [key: string]: string; // lang -> targetText
    };
    tokens?: string[]; // Simplified tokens from the current language
    tokensMap: {
        [key: string]: string[] | string[][];
    };
    tokensSlashMap: {
        [key: string]: string;
    };
};

export type Category = {
    id: string;
    name: string;
};

export type Language = {
    code: NativeLanguage;
    name: string;
    nativeName: string;
};

export const LANGUAGES: Language[] = [
    { code: "en", name: "English", nativeName: "English" },
    { code: "ja", name: "Japanese", nativeName: "日本語" },
    { code: "ko", name: "Korean", nativeName: "한국어" },
    { code: "zh", name: "Chinese (Simplified)", nativeName: "中文 (简体)" },
    { code: "fr", name: "French", nativeName: "Français" },
    { code: "es", name: "Spanish", nativeName: "Español" },
    { code: "de", name: "German", nativeName: "Deutsch" },
    { code: "ru", name: "Russian", nativeName: "Русский" },
    { code: "vi", name: "Vietnamese", nativeName: "Tiếng Việt" },
];

export const LANGUAGE_LOCALES: Record<string, string> = {
    en: "en-US",
    ja: "ja-JP",
    ko: "ko-KR",
    zh: "zh-CN",
    fr: "fr-FR",
    es: "es-ES",
    de: "de-DE",
    ru: "ru-RU",
    vi: "vi-VN",
};

export const GENDER_SUPPORTED_LANGUAGES = ["fr", "es", "ru", "de", "ar", "he", "hi"];

// Map file imports to language codes
const langPacks: Record<string, any[]> = {
    en, ja, ko, zh, fr, es, de, ru, vi
};

// Build PHRASES and CATEGORIES dynamically
const buildData = () => {
    const phraseMap: Record<string, Phrase> = {};
    const categorySet = new Set<string>();

    const allKeys = Object.keys(langPacks);

    // 1. Identify all unique frames and determine their split count (based on Korean or English)
    const frameIds = new Set<string>();
    allKeys.forEach(lang => {
        const pack = langPacks[lang] as LangPackItem[];
        pack.forEach(p => frameIds.add(p.frameId));
    });

    frameIds.forEach(frameId => {
        // Find the 'base' item to determine splitting. Prefer KO for nested tokens, then EN.
        const koItem = (langPacks['ko'] as LangPackItem[])?.find(p => p.frameId === frameId);
        const enItem = (langPacks['en'] as LangPackItem[])?.find(p => p.frameId === frameId);

        // Determine number of parts
        let numParts = 1;
        if (koItem && Array.isArray(koItem.item.tokens) && Array.isArray(koItem.item.tokens[0])) {
            numParts = koItem.item.tokens.length;
        } else if (enItem && enItem.item.targetText.includes('/')) {
            // Fallback: check slashes in English text. 
            // Note: This is a heuristic.
            numParts = enItem.item.targetText.split('/').length;
        }

        // Create sub-phrases
        for (let i = 0; i < numParts; i++) {
            const subId = numParts > 1 ? `${frameId}-${i}` : frameId;

            // Base metadata from any available item (using EN or first found)
            const baseItem = enItem || koItem || allKeys.map(k => (langPacks[k] as LangPackItem[]).find(p => p.frameId === frameId)).find(Boolean);

            if (!baseItem) continue;

            const newPhrase: Phrase = {
                id: subId,
                categoryId: baseItem.categoryId,
                translation: "", // Set later
                translations: {},
                tokensMap: {},
                tokensSlashMap: {}
            };

            // Populate per-language data
            allKeys.forEach(lang => {
                const p = (langPacks[lang] as LangPackItem[])?.find(p => p.frameId === frameId);
                if (!p) return;

                // 1. Text Splitting
                // Split by '/' but be careful about spaces. usually "Part1. / Part2." -> "Part1.", " Part2."
                const parts = p.item.targetText.split('/');
                let textPart = parts[i] || parts[0];
                textPart = textPart.trim();
                newPhrase.translations[lang] = textPart;

                // 2. Gloss Splitting (EN gloss)
                if (lang === 'en' && p.gloss_en) {
                    const glossParts = p.gloss_en.split('/');
                    newPhrase.translation = (glossParts[i] || glossParts[0]).trim();
                }

                // 3. Tokens Splitting
                let tokensPart: string[] = [];
                const rawTokens = p.item.tokens;

                if (Array.isArray(rawTokens) && Array.isArray(rawTokens[0])) {
                    // Nested structure (e.g. KO)
                    tokensPart = (rawTokens as string[][])[i] || [];
                } else if (Array.isArray(rawTokens)) {
                    // Flat structure (e.g. EN, ES)
                    const flatTokens = rawTokens as string[];

                    if (numParts === 1) {
                        tokensPart = flatTokens;
                    } else {
                        // Find split indices
                        const splitIndices: number[] = [0];
                        flatTokens.forEach((t, idx) => {
                            if (idx > 0 && t.startsWith('/')) { // Separator marker
                                splitIndices.push(idx);
                            }
                        });
                        splitIndices.push(flatTokens.length); // End marker

                        const start = splitIndices[i];
                        const end = splitIndices[i + 1];

                        if (start !== undefined && end !== undefined) {
                            tokensPart = flatTokens.slice(start, end);
                            // Clean the leading slash from the first token of this chunk
                            if (tokensPart.length > 0 && tokensPart[0].startsWith('/')) {
                                tokensPart[0] = tokensPart[0].substring(1);
                            }
                        } else {
                            tokensPart = flatTokens; // Fallback
                        }
                    }
                }
                newPhrase.tokensMap[lang] = tokensPart;

                // 4. TokensSlashMap - Split by '//' 
                const slashSegments = p.item.tokensSlash.split('//');
                newPhrase.tokensSlashMap[lang] = (slashSegments[i] || slashSegments[0]).trim();

            });

            // Failsafe for translation if EN missing
            if (!newPhrase.translation && newPhrase.translations['en']) {
                newPhrase.translation = newPhrase.translations['en'];
            }

            phraseMap[subId] = newPhrase;
            categorySet.add(baseItem.categoryId);
        }
    });

    const phrases = Object.values(phraseMap);
    const categories = Array.from(categorySet).map(id => ({
        id,
        name: formatCategoryName(id)
    }));

    return { phrases, categories };
};

const formatCategoryName = (id: string) => {
    // Determine a readable name from id like 'cb_negation_basic'
    // This is a simple formatter; you might want a manual map if precise names are needed.
    const parts = id.split('_');
    if (parts.length > 1) {
        return parts.slice(1).map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(' ');
    }
    return id; // Fallback
};

// Extract parent category from categoryId (e.g., 'cb_negation_basic' -> 'negation')
const getParentCategory = (categoryId: string): string => {
    const parts = categoryId.split('_');
    if (parts.length > 1) {
        return parts[1]; // e.g., 'negation', 'questions', 'tense', 'modality', 'location'
    }
    return categoryId;
};

const formatParentCategoryName = (id: string): string => {
    return id.charAt(0).toUpperCase() + id.slice(1);
};

const { phrases, categories } = buildData();

// Build parent categories from unique parent category IDs
const parentCategorySet = new Set<string>();
phrases.forEach(p => {
    parentCategorySet.add(getParentCategory(p.categoryId));
});

const parentCategories: Category[] = Array.from(parentCategorySet).map(id => ({
    id,
    name: formatParentCategoryName(id)
}));

export const PHRASES: Phrase[] = phrases;
export const CATEGORIES: Category[] = categories;
export const PARENT_CATEGORIES: Category[] = parentCategories;

// Helper to get parent category for a phrase
export const getParentCategoryId = (categoryId: string): string => {
    return getParentCategory(categoryId);
};

export const getPhrasesByCategory = (categoryId: string) => {
    if (categoryId === "all") return PHRASES;
    return PHRASES.filter((phrase) => phrase.categoryId === categoryId);
};

export const getPhrasesByParentCategory = (parentCategoryId: string) => {
    if (parentCategoryId === "all") return PHRASES;
    return PHRASES.filter((phrase) => getParentCategory(phrase.categoryId) === parentCategoryId);
};

export const getPhraseById = (id: string) => {
    return PHRASES.find((phrase) => phrase.id === id);
};
